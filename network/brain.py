'''
A neural network model that can be evolved using a genetic algorithm
'''

import numpy as np
from keras.models import Sequential
from keras.layers import Dense

input_dim = 10
Layers = 3
Neurons = [10, 10, 10]


def generate(data_dim=input_dim, layers=Layers, neurons=Neurons):
    '''
    Generate a neural network that can be trained
    inputs:
        data dimension -> the vector input
        layers -> the total number of layers minus the input layer
        neurons -> the number of neurons in hidden layer 1 to output layer
    output: a neural network
    '''
    brain = Sequential()
    brain.add(Dense(units=neurons[0], activation='relu', input_dim=data_dim))
    for i in range(1, layers):
        brain.add(Dense(units=neurons[i], activation='sigmoid'))

    return brain


def generate_offspring(weights):
    '''
    private function that should not be called. Generates an offspring and
    initializes it with the given weights
    input: a list of weights that contain the correct shaped weights for each layer
    output: a neural network that is initialized with the given weights
    '''
    baby_brain = generate()
    copy_weights = np.copy(weights)
    for layer in [baby_brain.get_layer(index=i) for i in range(Layers + 1)]:
        layer.set_weights([copy_weights[i - 1], layer.get_weights[1]])

    return baby_brain


def crossover(brainA, brainB):
    """
    Generates two new neural networks by weaving the weights of brain A and brain B
    inputs: two neural networks generated by the generate function
    outputs: a list of two new neural networks whose weights are a combination of the input neural networks
    """
    weightsA = [layer.get_weights()[0] for layer in [brainA.get_layer(index=i) for i in range(1, Layers + 1)]]
    weightsB = [layer.get_weights()[0] for layer in [brainB.get_layer(index=i) for i in range(1, Layers + 1)]]

    x, y = [X[:][i] for X in weightsA for i in range(X.shape[0])], [X[:][i] for X in weightsB for i in range(X.shape[0])]

    babyA = [np.random.choice([A, B]) for A, B in zip(x, y)]
    babyB = [np.random.choice([A, B]) for A, B in zip(x, y)]

    return [generate_offspring(np.array(babyA)), generate_offspring(np.array(babyB))]


def mutate(brain):
    """
    mutate the weights of the given network
    input: a neural network
    output: a neural network whose every column is multiplied by a random number between (0.25,1.25)
    """
    weights = [layer.get_weights()[0] for layer in [brain.get_layer(index=i) for i in range(1, Layers + 1)]]
    mutated_weights = [x * (np.random.sample() + 0.25) for x in [X[:][i] for X in weights for i in range(X.shape[0])]]

    return generate_offspring(np.array(mutated_weights))


def evolve(brains):
    '''
    need to implement how the brain evolves
    '''
    return None


def guess(brain, data):
    '''
    make the network predict an outcome based on the input
    '''
